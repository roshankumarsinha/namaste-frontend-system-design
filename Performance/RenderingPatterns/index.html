<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Rendering Pattern</h1>
    <ol>
        <li>
            <h3>Client-Side Rendering (CSR)</h3>
            <p><b>What is Client-Side Rendering (CSR)?</b></p>
            <p>Client-Side Rendering is a method where the browser (the client) is responsible for rendering the content of the web page after downloading it. This means the server initially sends an almost empty HTML file with a reference to the JavaScript code (bundled in a file). Once the browser downloads and executes the JavaScript, it fetches the necessary data (typically through APIs) and dynamically builds and updates the content on the page.</p>
            <p><b>How CSR Works (Step-by-Step)</b></p>
            <ol>
                <li><b>Initial Request:</b>The client (browser) sends a request to the server for a webpage (e.g., example.com/home).</li>
                <li><b>Empty HTML Response:</b>The server responds with an almost empty HTML file, which usually contains a minimal structure (such as <div id="root"></div>) and links to the JavaScript files needed for rendering the page.</li>
                <li><b>JavaScript Execution:</b>The browser downloads the JavaScript bundles and executes them. <br />
                    The JavaScript (typically from a framework/library like React, Vue, or Angular) takes control, fetches the necessary data from APIs or other services, and dynamically generates the HTML elements on the page.</li>
                <li><b>Hydration:</b>Then hydration(attaching event listeners) happens. Since it is a CSR hydration is easy and fast.</li>
                <li><b>Content Rendering:</b>Once the data is received and the DOM (Document Object Model) is updated, the page becomes interactive, and users can interact with the dynamic content (such as forms, buttons, and other interactive elements).</li>
                <li><b>Subsequent Navigation:</b>Unlike traditional multi-page websites where navigating to a new page would require a full page reload, CSR typically updates only parts of the page, ensuring smoother transitions between different sections (using routing techniques like React Router).</li>
            </ol>
            <p><b>Disadvantages of CSR:</b></p>
            <ul>
                <li><b>SEO Challenges:</b>One of the major drawbacks of CSR is SEO (Search Engine Optimization). Since the content is rendered in the browser and search engines often rely on static HTML for crawling and indexing, websites using CSR can be harder to optimize for search engines.</li>
                <li><b>Slow Initial Load (Time-to-First-Byte):</b>In CSR, the user initially receives a very basic HTML file, which doesn't contain much useful content. The browser then has to download and execute the JavaScript files, fetch data from APIs, and finally render the content.
                   <br /> This process can make the initial load slower, especially on slower connections or lower-end devices. This is often called "blank screen" syndrome as users might see a blank page until the JavaScript finishes loading.</li>
                <li><b>JavaScript Dependency:</b>Since CSR relies heavily on JavaScript, users with JavaScript disabled or unsupported in their browsers will not be able to access the site properly.</li>
            </ul>
        </li>
        <li>
            <p><b>What is Server-Side Rendering (SSR)?</b></p>
            <p>Server-Side Rendering (SSR) is a technique in which the server generates the full HTML for a webpage on every request and sends it to the client (browser). This is in contrast to Client-Side Rendering (CSR), where the browser receives a barebones HTML file and dynamically renders the page using JavaScript.

                In SSR, the initial HTML is pre-rendered on the server, meaning when the user requests a webpage, they receive a fully-formed HTML document. Once the HTML is loaded, client-side JavaScript may take over (similar to CSR), but the first load is faster because the user sees content immediately.</p>
            <p><b>How SSR Works (Step-by-Step)</b></p>
            <ol>
                <li><b>Request from the Client:</b>A user navigates to a webpage (e.g., example.com/products). The browser sends a request to the server for that page.</li>
                <li><b>Server Generates the HTML:</b>The server processes the request, often by querying a database or fetching data from an API.
                    The server then dynamically generates the HTML page using a template engine or a server-side framework (like Next.js for React).</li>
                <li><b>Response to the Client:</b>The server sends the fully rendered HTML to the browser, which displays the content to the user immediately.</li>
                <li><b>Client-Side Hydration:</b>Once the HTML is loaded, client-side JavaScript (if present) may take over to enhance interactivity and dynamic content. This process is known as hydration, where the client-side code attaches event listeners and updates the DOM as needed.</li>
            </ol>
            <p><b>Advantages of SSR:</b></p>
            <ul>
                <li><b>Improved SEO:</b>One of the key benefits of SSR is improved SEO performance. Search engines can easily crawl and index the content of SSR websites since the initial HTML is fully formed and contains all the necessary information.</li>
                <li><b>Faster Initial Load:</b>SSR typically results in faster initial load times compared to CSR. Since the server generates the full HTML, users see content immediately, reducing the "blank screen" effect often associated with CSR. SSR offers a much faster initial page load compared to CSR because the browser receives fully rendered HTML, which can be displayed immediately, even before JavaScript finishes loading.</li>
            </ul>
            <p><b>Disadvantages of SSR:</b></p>
            <ul>
                <li><b>Server Load:</b>SSR can put a heavier load on the server compared to CSR, as the server has to generate the full HTML for each request. This can impact server performance, especially under high traffic conditions.</li>
                <li><b>Complexity:</b>Implementing SSR can be more complex than CSR, especially for developers who are more familiar with client-side development. SSR requires server-side rendering logic, which may involve additional setup and configuration.</li>
            </ul>
            <p><b>Example of SSR using NextJS</b></p>
            <code>
                // pages/index.js
import React from 'react';

// getServerSideProps is a special Next.js function that fetches data server-side
export async function getServerSideProps() {
  // Simulate a data fetch (API call)
  const res = await fetch('https://api.example.com/products');
  const products = await res.json();

  // Return the data as props
  return { props: { products } };
}

const HomePage = ({ products }) => {
  return (
    <div>
      <h1>Products List (Server-Side Rendered)</h1>
      <ul>
        {products.map((product) => (
          <li key={product.id}>{product.name}</li>
        ))}
      </ul>
    </div>
  );
};

export default HomePage;

            </code>
        </li>
    </ol>
</body>
</html>

